# Actor, Thread and Me

The dRuby book : 絶版
dRubyによる分散Webプログラミング : 初刷り10周年

----

Actor model

"Actor is better than Thread"

マルチスレッドで発生する問題が解決する
スレッドなら書くのは難しい、アクターなら書ける、スレッドは💩、**ほんと？**

----

スレッド間のデータ交換を制限
複数のスレッドがデータを書き換えない

え？そこなの？

----

プロセスとスレッドの違い
  メモリ空間を共有できる
  メリットでありデメリットである
    つまりそれこそ特徴。

それならプロセスでいいのでは？

---

アクターモデルをおさらい。

---

アクターモデルとはただのモデル。
MVCみたいにただのモデル。better threadではない。

----

- Actor
- Message
- Ether

Messageには宛先を指定する
Actorは実行主体。プロセスとかスレッドとか実態は定義されていない。
messaging system:アクター間でメッセージを伝搬する

Ether(AEther) 光の波を伝えると仮想されていたもの

Send 自分の都合のいいときにメッセージを送る
Receive 自分の都合のいいときにメッセージを受け取る

アクターの生成もあるけど割愛

----

アクターモデルに見えるやつ
Win32などのEvent Drivenなやつ
N*de.jsとか

(Send -> ) Receive -> Working -> Send (-> Receive)

----

あとでやる作戦
→相互に依存するとやばい。あとでやるを持ったままreply待ち

まさにnon-blocking。システムが止まっているわけではないけど止まってる。
返信に限らず複数のメッセージを待つケース
  Future/Promiseでの問い合わせとか

共有資源の操作
  資源もアクターと考えるとうまくいくよ！
  
----

あとでやる作戦はだめだった

自分の都合のいいときのみ読み、処理し、書くためにはどうするか？

すべてのアクターが誰にも依存しないようにする→アクターの意味なし

正しくかけばうまくいく！→それはそう

そういうものだと受け入れる

----

event driven

途中経過をメモする遺言作戦 save context, restore context
しかし処理を自然に書けない

複数のコンテキストがあった？

----

Fiberの使い方に似てる？
ものスレッドで複数のコンテキスト、明示的なコンテキスト切り替え

止まる。
ブロックする処理で全部止まる。
ブロックしても全体は動かしたい。→そこでマルチスレッドですよ！

---

おすすめ

システム全体はアクターモデルで考えるけどアクターの中身はマルチスレッド
アクターの中身は実質的にマルチスレッドにならざるをえないんじゃないかなあ

----

github/seki/bartender

Fiber難しそうなので使ってみた
selectを抽象化するためのフレームワーク

App#[]=
App#delete
App#run ループ

以上。eventとfdを結びつけるだけ。

これだけでは不便なのでユーティリティーを。
non-block IOをblock風にする
blockしそうになったら実行権を手放す
  Fiber.yield

----

実験用クライアント: dRubyにした。
動いた。

----

解決しなかったこと
そのメソッドは長い処理をするか知る方法がない

----

自分のエーテルを作ろう、メッセージングシステム

Queue
TupleSpace

すべてのオブジェクトはqueueを持ってる
メソッド呼び出しを全てqueue
エーテルをそれぞれが持つスタイル

method_missingはqueueに積むだけ

なんでも直列化される

使わなかった。

----

中央集権型

Rinda::TupleSpace

まあ動く。
よく使ってるスタイル。

エーテル書いてて気がついた：
アクターとエーテル/メッセージングシステムの関係もアクターモデルなのでは？
自分と他者の関係
モデルとしてのアクターはどこにでもあるのでは？

----

モデルとしてのアクターをおさらい
より良いスレッドではないという気分を共有したい